# Code

Code, or expressions of work, tend to be a pervasive influence on how teams succeed over the long term, if people can collaborate, if work can be sustained - in some ways they embody not just the practice, the pragmatics, but also the politics of work. Expressions of work shape product, shape maintainability, participation.

The problem with code is that it expresses today, considerations that are not known until tomorrow. If we have an overly brittle architecture then we encounter the "platypus effect"; new things appear weird - not because they are weird - but because we didn't consider them. Of course the opposite is also true, all things appear equal and arbitrary, and it is hard to find a consensus about the right way to model the real world inside of our computer.

Code should be a "good enough" rough capture of a domain. In the same sense that a map isn't the territory, a model of a topic space should be helpful, but not coercive, and definitely not inaccurately modeling or capturing the topic in a way that peverts the real world topic itself.

Overly coercive patterns can limit participation, slow development, prevent exploration and iteration, make deep design changes too expensive, create attachment to existing work (sunk costs fallacy), but also destroy teams, dreams and waste our time, talent and treasure.

Code itself, especially if it mops up a lot of our attention because it is heavy, can focus us away from the largest discussions about the deep design intent, side-effects, meaning and purpose of an application. Any venture constantly needs to re-interrogate its deep design purpose, and the code should be secondary to that.

This can be very challenging. There are several ways however to have a light touch, to sketch out some contraints while not overly limiting participation or overly slowing development. Here we discuss a few patterns that hopefully will help us avoid the worst of these excesses.

## Code fundamentals 

1) **Avoid a mono-repo** / monolithic design philosophy. A data-centric architecture can simply be a database, with code in different languages talking to it. There doesn't have to even be a single agreed upon grammar, set of imports, conventions or tools.

2) **Layers**think about the product/service as as series of separate layers with clear api walls - behaviors desired at a high level can be invisible at a low leve.

3) **Pub/Sub** and message busses; allow late binding by allowing subscribers to attach to message busses. They're a great pattern for decoupling work.

4) **DRY. Modular. Granular**. As simple obvious best practices I tend to prefer smaller modular or DRY files that are reusable - even if they require some configuration parameters. This often comes up in layouts, for example many pages will layout out objects as cards, with some slight variation between cards, or say slight variations in the page header. I prefer to consolidate a "role" in a single file, and try to re-use that role as much as possible.

5) **Separate High from Low**. Even within a single file I prefer to NOT mix general conditional expressions of work with the act or labor that those conditionals do. An anti-pattern developers (and llms) often use is to have a conditional, then a large blob of work, then another conditional, then more work. I strongly prefer that the actual "work" be in a separate function (even if in the same file) that the conditional calls. In this way all of the higher level conditionals are themselves visible (ideally in a single page) as opposed to spaced out. In general work can be split into layers even within one file; simply use functions to encapsulate blobs of functionality where possible at least.

6) **Exit Early**. In a series of conditionals I prefer to handle the short cases and exit early; this comes from my experience writing machine code. We try to clear out as many cases as possible, exit those cases, and then deal with the largest remaining blocks last. An anti-pattern that developers and llms often use is to have a conditional, then a large block of code, then a short final condition - for example if(children) { do_a_ton_of_work() } else { print_no_children() }. The better pattern is if(!children) { print_no_children(); return}; do_a_ton_of_work(); . Developers may prefer to conditionally shroud both sides of the case, but at least do the early exits first rather than last - this reduces cognitive overhead.

7) **Right-sized abstractions**. Every single application always invents its own grammar. Effectively the functions, the API end-points, the imports and exposed functions are conceptually the act of defining a grammar that captures a "right sized" representation of the problem space. The nouns and verbs are the function end points. It's important to find the right abstraction, that is "good enough" to allow succinct high level operations that manipulate the state of the system as desired. Often developers (as an anti-pattern) will either be too low or too high; they will over expose granular building blocks that bulk out high level operations with repetitive labor, or too high, single functions that take dozens of parameters. An example of an anti-pattern here is separate api calls for every single database entity you want to create such as createPlace, createEvent, createArtifact - if these are all in the same table then a createEntity abstraction may be more about the "right size".

8) **Avoid premature schema optimization**. Often developers will overly fixate on schema representation and partitioning the state space of a problem. This is especially common with SQL. It's more important to ship, and any impediment to shipping, that becomes a carrying cost during development, is highly discouraged. That's why I often use only a single table (Entity) or very few tables - the beefy base class "anti-pattern" is actually best for rapid prototyping when you're in research mode, exploring a space, and you don't know what the actual final set of artifacts are or how you're going to partition the space conceptually. I also refer to this as the "platypus problem" - where early disjoint directed acyclic graph based categorization makes totally ordinary entities, that we come across last, feel bizarre, because they contradict the particular lens which we've composed to view the world.

9) **Avoid inversion of control**. Often developers will shroud or wrap functionality in wrapper state, such as "render this layout only if the participant is logged in" - passing the layout to an auth wrapper. It's better to just early out the non-authenticated case, and then separately deal with authenticated cases. The preferred pattern is "compositional" rather than inheritance or wrapping.

10) **ECS**. In a similar vein I prefer Entity Control Systems with prototype based instancing rather than abstract base classes and inheritance. Typically there is a basic Entity that has no properties innately, and then it is decorated with different 'capabilities' or 'components' that allow a compisitional way of expressing complex objects. This also avoids OOPS anti-patterns that were popular for several years. This pattern is now more mature and less contested, and we see strong support for compositional expressions of state in modern grammars and databases. Note this preferred pattern can be more verbose - while ie can be convenient to have a concept of "BaseAnimal" and then have "Cat" inherit "BaseAnimal" it's better to have "Cat" simply be a composition of discrete parts such as { motile, eats, purrs }.

11) **Declarative**. I strongly lean towards declarative expressions of work as separate loadable files rather than procedurally declaring state at startup. I believe that there's a way to express most "complex systems" as declative manifests that "produce" the living system by inhalation of state into a runtime model using a generic loader. I tend to be resistant to the idea of a main() routine that by-hand, manually and procedurally stands up all of the individual artifacts that describe a system.
