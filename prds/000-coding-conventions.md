# General Coding practices

1) **DRY. Modular. Granular**. As simple obvious best practices I tend to prefer smaller modular or DRY files that are reusable - even if they require some configuration parameters. This often comes up in layouts, for example many pages will layout out objects as cards, with some slight variation between cards, or say slight variations in the page header. I prefer to consolidate a "role" in a single file, and try to re-use that role as much as possible.

2) **Separate High from Low**. I prefer to NOT mix general conditional expressions of work with the act or labor that those conditionals do. An anti-pattern developers (and llms) often use is to have a conditional, then a large blob of work, then another conditional, then more work. I strongly prefer that the actual "work" be in a separate function (even if in the same file) that the conditional calls. In this way all of the higher level conditionals are themselves visible (ideally in a single page) as opposed to spaced out.

3) **Exit Early**. In a series of conditionals I prefer to handle the short cases and exit early; this comes from my experience writing machine code. We try to clear out as many cases as possible, exit those cases, and then deal with the largest remaining blocks last. An anti-pattern that developers and llms often use is to have a conditional, then a large block of code, then a short final condition - for example if(children) { do_a_ton_of_work() } else { print_no_children() }. The better pattern is if(!children) { print_no_children(); return}; do_a_ton_of_work(); . Developers may prefer to conditionally shroud both sides of the case, but at least do the early exits first rather than last - this reduces cognitive overhead.

4) **Right-sized abstractions**. Every single application always invents its own grammar. Effectively the functions, the API end-points, the imports and exposed functions are conceptually the act of defining a grammar that captures a "right sized" representation of the problem space. The nouns and verbs are the function end points. It's important to find the right abstraction, that is "good enough" to allow succinct high level operations that manipulate the state of the system as desired. Often developers (as an anti-pattern) will either be too low or too high; they will over expose granular building blocks that bulk out high level operations with repetitive labor, or too high, single functions that take dozens of parameters. An example of an anti-pattern here is separate api calls for every single database entity you want to create such as createPlace, createEvent, createArtifact - if these are all in the same table then a createEntity abstraction may be more about the "right size".

5) **Avoid premature schema optimization**. Often developers will overly fixate on schema representation and partitioning the state space of a problem. This is especially common with SQL. It's more important to ship, and any impediment to shipping, that becomes a carrying cost during development, is highly discouraged. That's why I often use only a single table (Entity) or very few tables - the beefy base class "anti-pattern" is actually best for rapid prototyping when you're in research mode, exploring a space, and you don't know what the actual final set of artifacts are or how you're going to partition the space conceptually. I also refer to this as the "platypus problem" - where early disjoint directed acyclic graph based categorization makes totally ordinary entities, that we come across last, feel bizarre, because they contradict the particular lens which we've composed to view the world.

6) **Avoid inversion of control**. Often developers will shroud or wrap functionality in wrapper state, such as "render this layout only if the participant is logged in" - passing the layout to an auth wrapper. It's better to just early out the non-authenticated case, and then separately deal with authenticated cases. The preferred pattern is "compositional" rather than inheritance or wrapping.

7) **ECS**. In a similar vein I prefer Entity Control Systems with prototype based instancing rather than abstract base classes and inheritance. Typically there is a basic Entity that has no properties innately, and then it is decorated with different 'capabilities' or 'components' that allow a compisitional way of expressing complex objects. This also avoids OOPS anti-patterns that were popular for several years. This pattern is now more mature and less contested, and we see strong support for compositional expressions of state in modern grammars and databases. Note this preferred pattern can be more verbose - while ie can be convenient to have a concept of "BaseAnimal" and then have "Cat" inherit "BaseAnimal" it's better to have "Cat" simply be a composition of discrete parts such as { motile, eats, purrs }.

8) **Declarative**. I strongly lean towards declarative expressions of work as separate loadable files rather than procedurally declaring state at startup. I believe that there's a way to express most "complex systems" as declative manifests that "produce" the living system by inhalation of state into a runtime model using a generic loader. I tend to be resistant to the idea of a main() routine that by-hand, manually and procedurally stands up all of the individual artifacts that describe a system.
